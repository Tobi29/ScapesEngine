/*
 * Copyright 2017, Gray Watson
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package com.j256.simplemagik.entries

import com.j256.simplemagik.endian.EndianType
import com.j256.simplemagik.endian.convert
import com.j256.simplemagik.types.parseId3
import org.tobi29.arrays.BytesRO
import org.tobi29.logging.KLogging
import org.tobi29.stdex.combineToInt
import org.tobi29.stdex.combineToShort

/**
 * Representation of a line of information from the magic (5) format. A number of methods are package protected because
 * this is generated by the [MagicEntryParser].
 *
 * @author graywatson
 */
class MagicEntry
/**
 * Package protected constructor.
 */
internal constructor(
    private val name: String?,
    /**
     * Return the "level" of the rule. Level-0 rules start the matching process. Level-1 and above rules are processed
     * only when the level-0 matches.
     */
    internal val level: Int,
    private val addOffset: Boolean,
    private val offset: Int,
    private val offsetInfo: OffsetInfo?,
    private val matcher: MagicMatcher,
    private val formatSpacePrefix: Boolean,
    private val clearFormat: Boolean,
    private val formatter: Lazy<MagicFormatter>?
) {
    /** if this entry matches then check the children entry(s) which may provide more content type details  */
    private val children = ArrayList<MagicEntry>()
    internal var mimeType: String? = null
    internal var isOptional: Boolean = false

    internal val startsWithByte: ByteArray?
        get() = if (offset != 0) null else matcher.startingBytes

    internal fun addChild(child: MagicEntry) {
        children.add(child)
    }

    override fun toString(): String {
        val sb = StringBuilder()
        sb.append("level ").append(level)
        val name = name
        val mimeType = mimeType
        val formatter = formatter
        if (name != null) {
            sb.append(",name '").append(name).append('\'')
        }
        if (mimeType != null) {
            sb.append(",mime '").append(mimeType).append('\'')
        }
        sb.append(",test '").append(matcher).append('\'')
        if (formatter != null) {
            sb.append(",format '").append(formatter).append('\'')
        }
        return sb.toString()
    }

    /**
     * Main processing method which can go recursive.
     */
    internal fun matchBytes(
        bytes: BytesRO,
        indirect: ContentData? = null,
        contentData: ContentData? = null,
        prevOffset: Int = 0,
        level: Int = 0
    ): ContentData? {
        var contentData = contentData
        val offset2 = (offsetInfo?.getOffset(bytes, prevOffset) ?: this.offset)
            .let { if (addOffset) it + prevOffset else it }
        if (offset2 !in 0..bytes.size) return null
        val (offset1, match) =
                matcher.isMatch(bytes.slice(offset2), formatter != null)
                        ?: return null
        val offset = offset1 + offset2

        if (contentData == null) {
            contentData = ContentData()
            if (indirect != null) {
                contentData.mimeType = indirect.mimeType
                contentData.mimeTypeLevel = indirect.mimeTypeLevel
                contentData.messageBuilder.addAll(indirect.messageBuilder)
            }
            // default is a child didn't match, set a partial so the matcher will keep looking
            contentData.partial = true
        }
        if (formatter != null) {
            if (clearFormat) {
                contentData.messageBuilder.clear()
            }
            contentData.messageBuilder.add {
                // if we are appending and need a space then prepend one
                if (formatSpacePrefix && isNotEmpty()) append(' ')
                match(this, formatter.value)
            }
        }
        if (matcher.isIndirect) contentData.indirect = true
        if (children.isEmpty()) contentData.offset = offset
        logger.trace { "matched data: $this: $contentData" }

        if (name != null) {
            contentData.name = name
        }

        if (children.isEmpty()) {
            // no children so we have a full match and can set partial to false
            contentData.partial = false
        } else {
            // run through the children to add more content-type details
            var allOptional = true
            for (entry in children) {
                if (!entry.isOptional) {
                    allOptional = false
                }
                // goes recursive here
                entry.matchBytes(
                    bytes, indirect, contentData, offset, level + 1
                )
                // we continue to match to see if we can add additional children info to the name
            }
            if (allOptional) {
                contentData.partial = false
            }
        }

        /*
		 * Set the mime-type if it is not set already or if we've gotten more specific in the processing of a pattern
		 * and determine that it's actually a different type so we can override the previous mime-type. Example of this
		 * is Adobe Illustrator which looks like a PDF but has extra stuff in it.
		 */
        if (mimeType != null && (contentData.mimeType == null || level > contentData.mimeTypeLevel)) {
            contentData.mimeType = mimeType
            contentData.mimeTypeLevel = level
        }
        return contentData
    }

    /**
     * Internal processing data about the content.
     */
    internal data class ContentData(
        var name: String? = null,
        var mimeType: String? = null,
        var mimeTypeLevel: Int = -1,
        var partial: Boolean = false,
        var indirect: Boolean = false,
        var offset: Int = 0,
        val messageBuilder: MutableList<StringBuilder.() -> Unit> = ArrayList()
    ) {
        val message get() = buildString { messageBuilder.forEach { it() } }
    }

    /**
     * Information about the extended offset.
     */
    internal class OffsetInfo(
        val offset: Int,
        val endianType: EndianType,
        val addOffset: Boolean,
        val isId3: Boolean,
        val size: Int,
        val add: Int
    ) {
        fun getOffset(
            bytes: BytesRO,
            prevOffset: Int
        ): Int? {
            if (bytes.size - offset < size) return null
            val value = if (isId3) when (size) {
                4 -> combineToInt(
                    bytes[offset + 0],
                    bytes[offset + 1],
                    bytes[offset + 2],
                    bytes[offset + 3]
                ).convert(endianType).parseId3()
                else -> error("Invalid size: $size")
            } else when (size) {
                1 -> bytes[offset + 0].toInt() and 0xFF
                2 -> combineToShort(
                    bytes[offset + 0],
                    bytes[offset + 1]
                ).convert(endianType).toInt() and 0xFFFF
                4 -> combineToInt(
                    bytes[offset + 0],
                    bytes[offset + 1],
                    bytes[offset + 2],
                    bytes[offset + 3]
                ).convert(endianType)
                else -> error("Invalid size: $size")
            }
            return (value + add).let { if (addOffset) it + prevOffset else it }
        }
    }

    companion object : KLogging()
}
