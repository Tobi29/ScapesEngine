/*
 * Copyright 2012-2016 Tobi29
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.stream.Collectors

apply from: "$rootDir/ScapesEngine/resources/scapesenginemodulekotlin.gradle"
apply plugin: "idea"

configurations {
    runtimeLinux32
    runtimeLinux64
    runtimeMacOSX
    runtimeWindows32
    runtimeWindows64
    runtimePlatform
    nativesLinux32
    nativesLinux64
    nativesMacOSX
    nativesWindows32
    nativesWindows64
    nativesPlatform

    String os = System.properties["os.name"].toLowerCase()
    String arch = System.properties["os.arch"]
    if (os.contains("linux")) {
        if (arch.contains("64")) {
            runtimePlatform.extendsFrom runtimeLinux64
            nativesPlatform.extendsFrom nativesLinux64
        } else {
            runtimePlatform.extendsFrom runtimeLinux32
            nativesPlatform.extendsFrom nativesLinux32
        }
    } else if (os.contains("mac")) {
        runtimePlatform.extendsFrom runtimeMacOSX
        nativesPlatform.extendsFrom nativesMacOSX
    } else if (os.contains("windows")) {
        if (arch.contains("64")) {
            runtimePlatform.extendsFrom runtimeWindows64
            nativesPlatform.extendsFrom nativesWindows64
        } else {
            runtimePlatform.extendsFrom runtimeWindows32
            nativesPlatform.extendsFrom nativesWindows32
        }
    }
}

afterEvaluate {
    sourceSets.main.runtimeClasspath += configurations.runtimePlatform

    idea {
        module {
            scopes.RUNTIME.plus += [configurations.runtimePlatform]
        }
    }
}

idea {
    module {
        excludeDirs += file("$rootDir/runtime")
    }
}

apply plugin: ScapesEngineApplication

class ScapesEngineApplication implements Plugin<Project> {
    private ScapesEngineApplicationExtension appExtension

    @Override
    void apply(Project target) {
        // Application properties
        target.extensions.
                create("application", ScapesEngineApplicationExtension)

        // Natives task
        def nativesTask = target.tasks.create("natives", Copy)
        nativesTask.description = "Extract natives for runtime"
        nativesTask.group = "run"
        def natives = new File(target.buildDir, "natives")
        nativesTask.from({ ->
            target.configurations.nativesPlatform.files.stream().
                    map({
                        if (it.name.endsWith(".jar")) {
                            return target.zipTree(it).files.stream().filter({
                                it.isFile() && it.name.matches(
                                        "(.+)\\.(dll|so(.[0-9]+)?|jnilib|dylib)")
                            }).collect(Collectors.toList())
                        } else {
                            return it
                        }
                    }).collect(Collectors.toList())
        }) {
            eachFile { FileCopyDetails fcp ->
                String[] segments = [fcp.name]
                fcp.relativePath = new RelativePath(true, segments)
                fcp.setMode(0755)
            }
        }
        nativesTask.into natives

        // Run task
        def runTask = target.tasks.create("run", JavaExec)
        runTask.description = "Runs this project as a JVM application"
        runTask.group = "Run"
        runTask.conventionMapping.main = { target.application.mainClass }
        target.afterEvaluate {
            runTask.classpath = target.sourceSets.main.runtimeClasspath
        }
        runTask.jvmArgs "-Xms64M", "-Xmx2048M", "-XX:+UseG1GC",
                "-XX:MaxGCPauseMillis=1"
        if (target.rootProject.hasProperty("runArgs")) {
            runTask.args Eval.me(target.rootProject.runArgs)
        }
        if (target.rootProject.hasProperty("jvmArgs")) {
            runTask.jvmArgs Eval.me(target.rootProject.jvmArgs)
        }
        if (target.rootProject.hasProperty("runEnv")) {
            runTask.environment.putAll Eval.me(target.rootProject.runEnv)
        }
        if (System.properties["os.name"].toLowerCase().contains("mac")) {
            runTask.jvmArgs "-XstartOnFirstThread"
        }
        if (target.rootProject.hasProperty("runtime")) {
            runTask.jvmArgs "-Duser.dir=$target.rootProject.runtime"
        } else {
            runTask.jvmArgs "-Duser.dir=${target.file('runtime')}"
        }
        runTask.jvmArgs "-Djava.library.path=$natives.absolutePath"
        runTask.standardInput = System.in
        runTask.dependsOn target.classes
        runTask.dependsOn nativesTask

        // Platform deploy tasks
        def deployLinux32Task = addDeployLinuxTask(target, "32",
                target.configurations.runtimeLinux32,
                target.configurations.nativesLinux32)
        def deployLinux64Task = addDeployLinuxTask(target, "64",
                target.configurations.runtimeLinux64,
                target.configurations.nativesLinux64)
        def deployMacOSXTask = addDeployMacOSXTask(target)
        def deployWindowsTask = addDeployWindowsTask(target)

        // Full deploy task
        def deployTask = target.tasks.create("deploy", Task)
        deployTask.group = "Deployment"
        if (deployLinux32Task != null) {
            deployTask.dependsOn deployLinux32Task
        }
        if (deployLinux64Task != null) {
            deployTask.dependsOn deployLinux64Task
        }
        if (deployMacOSXTask != null) {
            deployTask.dependsOn deployMacOSXTask
        }
        if (deployWindowsTask != null) {
            deployTask.dependsOn deployWindowsTask
        }
    }

    private Task addDeployLinuxTask(Project target, String arch,
            Configuration runtime, Configuration natives) {
        def name = "${-> target.application.name.toLowerCase()}"
        def libPath = "/usr/share/java"
        if (target.rootProject.hasProperty("libPath")) {
            libPath = target.rootProject.libPath
        }
        def binPath = "/usr/bin"
        if (target.rootProject.hasProperty("binPath")) {
            binPath = target.rootProject.binPath
        }

        // Script task
        def scriptTask = target.tasks.
                create("scriptLinux$arch", StartupScriptTask)
        scriptTask.execName = name
        scriptTask.libPath = "$libPath/$name"
        scriptTask.mainClass = "${-> target.application.mainClass}"
        scriptTask.output = { new File(scriptTask.temporaryDir, name) }

        // Main task
        def task = target.tasks.create("deployLinux$arch", Tar)
        task.dependsOn scriptTask
        task.description =
                "Contains tarball that can be extracted into root for easier package creation"
        task.group = "Deployment"
        task.dependsOn target.jar
        target.afterEvaluate {
            task.baseName = "${-> target.application.name}-Linux$arch"
        }
        task.compression = Compression.GZIP
        task.from({ -> scriptTask.output }, { into "$binPath" })
        task.from(target.configurations.runtime + runtime +
                target.files(target.jar),
                { into "$libPath/$name" })
        task.from({ ->
            natives.files.stream().
                    map({
                        if (it.name.endsWith(".jar")) {
                            target.zipTree(it).files.stream().filter({
                                it.isFile() &&
                                        it.name.matches("(.+)\\.so(.[0-9]+)?")
                            }).collect(Collectors.toList())
                        } else {
                            return it
                        }
                    }).collect(Collectors.toList())
        }) {
            eachFile { FileCopyDetails fcp ->
                String[] segments = [libPath, name, fcp.name]
                fcp.relativePath = new RelativePath(true, segments)
                fcp.setMode(0755)
            }
        }
        return task
    }

    private Task addDeployMacOSXTask(Project target) {
        // JRE Task
        def jreTask = jreTask(target, "jreMacOSX", "MacOSX")
        if (jreTask == null) {
            target.logger.warn "No JRE for Mac OS X found!"
            return null
        }
        pruneJREMacOSX(jreTask, "*/Contents/Home")

        // Bundle task
        def bundleTask = target.tasks.create("bundleMacOSX", AppBundlerTask)
        bundleTask.dependsOn jreTask
        bundleTask.dependsOn target.jar
        bundleTask.fullName = "${-> target.application.fullName}"
        bundleTask.version = "${-> target.application.version}"
        bundleTask.company = "${-> target.application.company}"
        bundleTask.copyright = "${-> target.application.copyright}"
        bundleTask.mainClass = "${-> target.application.mainClass}"
        bundleTask.appbundler = {
            target.rootProject.
                    file("ScapesEngine/resources/appbundler-1.0ea.jar")
        }
        bundleTask.jre = { jreTask.temporaryDir }
        bundleTask.icon = "project/Icon.icns"
        bundleTask.classpath = target.configurations.runtime +
                target.configurations.runtimeMacOSX + target.files(target.jar)
        bundleTask.output = {
            new File(bundleTask.temporaryDir,
                    "${-> target.application.fullName}.app")
        }

        // Natives task
        def nativesTask = target.tasks.create("nativesMacOSX", Copy)
        nativesTask.dependsOn bundleTask
        nativesTask.from({ ->
            target.configurations.nativesMacOSX.files.stream().
                    map({
                        if (it.name.endsWith(".jar")) {
                            target.zipTree(it).files.stream().filter({
                                it.isFile() &&
                                        it.name.matches("(.+)\\.(jnilib|dylib)")
                            }).collect(Collectors.toList())
                        } else {
                            return it
                        }
                    }).collect(Collectors.toList())
        }) {
            eachFile { FileCopyDetails fcp ->
                String[] segments = [fcp.name]
                fcp.relativePath = new RelativePath(true, segments)
                fcp.setMode(0755)
            }
        }
        nativesTask.into "${-> bundleTask.output}/Contents/MacOS"

        // Main task
        def task = target.tasks.create("deployMacOSX", Tar)
        task.description =
                "Mac OS X Application containing necessary files to run the game"
        task.group = "Deployment"
        task.dependsOn nativesTask
        target.afterEvaluate {
            task.baseName = "${target.application.name}-MacOSX"
        }
        task.compression = Compression.GZIP
        task.from bundleTask.output.parentFile
        return task
    }

    private Task addDeployWindowsTask(Project target) {
        // JRE Task 64-Bit
        def jreTask32 = jreTask(target, "jreWindows32", "Windows/32")
        if (jreTask32 == null) {
            target.logger.warn "No 32-Bit JRE for Windows found!"
            return null
        }
        pruneJREWindows(jreTask32, "*")

        // JRE Task 64-Bit
        def jreTask64 = jreTask(target, "jreWindows64", "Windows/64")
        if (jreTask64 == null) {
            target.logger.warn "No 64-Bit JRE for Windows found!"
            return null
        }
        pruneJREWindows(jreTask64, "*")

        // Program task
        def programTask = target.tasks.create("programWindows", Launch4jTask)
        programTask.fullName = "${-> target.application.fullName}"
        programTask.version = "${-> target.application.version}"
        programTask.company = "${-> target.application.company}"
        programTask.copyright = "${-> target.application.copyright}"
        programTask.mainClass = "${-> target.application.mainClass}"
        programTask.launch4j = target.rootProject.
                file("ScapesEngine/resources/Launch4j/launch4j.jar")
        programTask.icon = target.file("project/Icon.ico")
        programTask.exeMemoryMin = 64
        programTask.exeMemoryMax = 2048
        programTask.exeType = "gui"
        programTask.runInAppData = true
        programTask.manifest = target.rootProject.
                file("ScapesEngine/resources/Program.manifest")
        programTask.output = {
            new File(programTask.temporaryDir,
                    "${-> target.application.name}.exe")
        }

        // Command task
        def programCmdTask = target.tasks.
                create("programCmdWindows", Launch4jTask)
        programCmdTask.fullName = "${-> target.application.fullName}"
        programCmdTask.version = "${-> target.application.version}"
        programCmdTask.company = "${-> target.application.company}"
        programCmdTask.copyright = "${-> target.application.copyright}"
        programCmdTask.mainClass = "${-> target.application.mainClass}"
        programCmdTask.launch4j = target.rootProject.
                file("ScapesEngine/resources/Launch4j/launch4j.jar")
        programCmdTask.icon = target.file("project/Icon.ico")
        programCmdTask.exeMemoryMin = 64
        programCmdTask.exeMemoryMax = 2048
        programCmdTask.exeType = "console"
        programCmdTask.runInAppData = false
        programCmdTask.manifest = target.rootProject.
                file("ScapesEngine/resources/Program.manifest")
        programCmdTask.output = {
            new File(programCmdTask.temporaryDir,
                    "${-> target.application.name}Cmd.exe")
        }

        // Prepare Task
        def prepareTask = target.tasks.create("prepareWindows", Copy)
        prepareTask.dependsOn jreTask32
        prepareTask.dependsOn jreTask64
        prepareTask.dependsOn target.jar
        prepareTask.dependsOn programTask
        prepareTask.dependsOn programCmdTask
        prepareTask.from target.rootProject.
                file("ScapesEngine/resources/Setup.iss")
        prepareTask.from target.file("project/installer")
        prepareTask.from({ programTask.output }, { into "install/common" })
        prepareTask.from({ programCmdTask.output }, { into "install/common" })
        prepareTask.from(target.files(target.jar),
                { into "install/common/lib" })
        prepareTask.from(target.configurations.runtime,
                { into "install/common/lib" })
        prepareTask.from({ ->
            target.configurations.nativesWindows32.files.stream().
                    map({
                        if (it.name.endsWith(".jar")) {
                            target.zipTree(it).files.stream().filter({
                                it.isFile() && it.name.matches("(.+)\\.dll")
                            }).collect(Collectors.toList())
                        } else {
                            return it
                        }
                    }).collect(Collectors.toList())
        }) {
            eachFile { FileCopyDetails fcp ->
                String[] segments = ["install", "32", name]
                fcp.relativePath = new RelativePath(true, segments)
                fcp.setMode(0755)
            }
        }
        prepareTask.from({ ->
            target.configurations.nativesWindows64.files.stream().
                    map({
                        if (it.name.endsWith(".jar")) {
                            target.zipTree(it).files.stream().filter({
                                it.isFile() && it.name.matches("(.+)\\.dll")
                            }).collect(Collectors.toList())
                        } else {
                            return it
                        }
                    }).collect(Collectors.toList())
        }) {
            eachFile { FileCopyDetails fcp ->
                String[] segments = ["install", "64", name]
                fcp.relativePath = new RelativePath(true, segments)
                fcp.setMode(0755)
            }
        }
        prepareTask.from(target.configurations.runtimeWindows32,
                { into "install/32/lib" })
        prepareTask.from(target.configurations.runtimeWindows64,
                { into "install/64/lib" })
        prepareTask.from({ jreTask32.temporaryDir }, { into "install/32/jre" })
        prepareTask.from({ jreTask64.temporaryDir }, { into "install/64/jre" })
        prepareTask.from(target.rootProject.
                file("ScapesEngine/resources/Install/Windows"),
                { into "install" })
        prepareTask.into prepareTask.temporaryDir

        // Pack task
        def packTask = target.tasks.create("packWindows", Exec)
        packTask.dependsOn prepareTask
        def innoEXE = target.rootProject.
                file(
                        "ScapesEngine/resources/Inno Setup 5/ISCC.exe").absolutePath
        def innoArgs = ["/DApplicationFullName=${-> escapeWindows(target.application.fullName)}",
                "/DApplicationVersion=${-> escapeWindows(target.application.version)}",
                "/DApplicationCompany=${-> escapeWindows(target.application.company)}",
                "/DApplicationCopyright=${-> escapeWindows(target.application.copyright)}",
                "/DApplicationURL=${-> escapeWindows(target.application.url)}",
                "/DApplicationUUID=${-> escapeWindows(target.application.uuid)}",
                "/DApplicationName=${-> escapeWindows(target.application.name)}"]
        def innoISS = new File(prepareTask.temporaryDir,
                "Setup.iss").absolutePath
        if (System.properties["os.name"].toLowerCase().contains("win")) {
            def commandLine = [innoEXE]
            commandLine += innoArgs
            commandLine += innoISS
            packTask.commandLine commandLine
        } else {
            def commandLine = ["wine", innoEXE]
            commandLine += innoArgs
            commandLine += "Z:${innoISS}"
            packTask.commandLine commandLine
        }

        // Main task
        def task = target.tasks.create("deployWindows", Copy)
        task.dependsOn packTask
        task.group = "Deployment"
        task.description = "Windows Installer with bundled JRE"
        task.from new File(prepareTask.temporaryDir, "output/setup.exe")
        task.rename({
            "${-> target.application.name}-Setup-${-> target.project.version}.exe"
        })
        task.into new File(target.buildDir, "distributions")
        return task
    }

    private static Sync jreTask(Project target, String name, String platform) {
        def jre = getJRE(target, platform)
        if (jre == null) {
            return null
        }
        def task = target.tasks.create(name, Sync)
        task.from { target.tarTree(jre) }
        task.into "${-> task.temporaryDir}"
        task.includeEmptyDirs = false
        task.eachFile { FileCopyDetails fcp ->
            def segments = fcp.relativePath.segments
            String[] newSegments
            if (segments.length <= 1) {
                newSegments = new String[0]
            } else {
                newSegments = segments[1..-1]
            }
            fcp.relativePath = new RelativePath(true, newSegments)
        }
        return task
    }

    private static File getJRE(Project target, String platform) {
        def jres = target.rootProject.
                file("ScapesEngine/resources/JRE/$platform").
                listFiles((FileFilter) { !it.isDirectory() && !it.isHidden() })
        if (jres == null || jres.length == 0) {
            return null
        }
        return jres[0]
    }

    private static void pruneJREMacOSX(CopySpec copy, String dir) {
        pruneJRE(copy, dir)

        copy.exclude "$dir/bin/javaws"
        copy.exclude "$dir/bin/orbd"
        copy.exclude "$dir/bin/policytool"
        copy.exclude "$dir/bin/keytool"
        copy.exclude "$dir/bin/rmid"
        copy.exclude "$dir/bin/rmiregistry"
        copy.exclude "$dir/bin/servertool"
        copy.exclude "$dir/bin/tnameserv"

        copy.exclude "$dir/lib/libdecora_sse.dylib"
        copy.exclude "$dir/lib/libfxplugins.dylib"
        copy.exclude "$dir/lib/libglass.dylib"
        copy.exclude "$dir/lib/libglib-lite.dylib"
        copy.exclude "$dir/lib/libgstreamer-lite.dylib"
        copy.exclude "$dir/lib/libjavafx_font.dylib"
        copy.exclude "$dir/lib/libjavafx_font_t2k.dylib"
        copy.exclude "$dir/lib/libjavafx_iio.dylib"
        copy.exclude "$dir/lib/libjfxmedia.dylib"
        copy.exclude "$dir/lib/libjfxwebkit.dylib"
        copy.exclude "$dir/lib/libprism_common.dylib"
        copy.exclude "$dir/lib/libprism_es2.dylib"
        copy.exclude "$dir/lib/libprism_sw.dylib"
    }

    private static void pruneJREWindows(CopySpec copy, String dir) {
        pruneJRE(copy, dir)

        copy.exclude "$dir/bin/dtplugin/**"
        copy.exclude "$dir/bin/plugin2/**"
        copy.exclude "$dir/bin/jabswitch.exe"
        copy.exclude "$dir/bin/javacpl.cpl"
        copy.exclude "$dir/bin/javacpl.exe"
        copy.exclude "$dir/bin/javaws.exe"
        copy.exclude "$dir/bin/jucheck.exe"
        copy.exclude "$dir/bin/kinit.exe"
        copy.exclude "$dir/bin/klist.exe"
        copy.exclude "$dir/bin/ktab.exe"
        copy.exclude "$dir/bin/orbd.exe"
        copy.exclude "$dir/bin/policytool.exe"
        copy.exclude "$dir/bin/keytool.exe"
        copy.exclude "$dir/bin/rmid.exe"
        copy.exclude "$dir/bin/rmiregistry.exe"
        copy.exclude "$dir/bin/servertool.exe"
        copy.exclude "$dir/bin/tnameserv.exe"

        copy.exclude "$dir/lib/deploy/**"
        copy.exclude "$dir/lib/deploy.jar"
        copy.exclude "$dir/lib/plugin.jar"

        copy.exclude "$dir/bin/java_crw_demo.dll"
        copy.exclude "$dir/bin/JavaAccessBridge-32.dll"
        copy.exclude "$dir/bin/JavaAccessBridge.dll"
        copy.exclude "$dir/bin/JAWTAccessBridge-32.dll"
        copy.exclude "$dir/bin/JAWTAccessBridge.dll"
        copy.exclude "$dir/bin/WindowsAccessBridge-32.dll"
        copy.exclude "$dir/bin/WindowsAccessBridge.dll"
        copy.exclude "$dir/bin/wsdetect.dll"
        copy.exclude "$dir/bin/deploy.dll"
        copy.exclude "$dir/bin/jfr.dll"
        copy.exclude "$dir/bin/decora_sse.dll"
        copy.exclude "$dir/bin/fxplugins.dll"
        copy.exclude "$dir/bin/glass.dll"
        copy.exclude "$dir/bin/glib-lite.dll"
        copy.exclude "$dir/bin/gstreamer-lite.dll"
        copy.exclude "$dir/bin/javafx_font.dll"
        copy.exclude "$dir/bin/javafx_font_t2k.dll"
        copy.exclude "$dir/bin/javafx_iio.dll"
        copy.exclude "$dir/bin/jfxmedia.dll"
        copy.exclude "$dir/bin/jfxwebkit.dll"
        copy.exclude "$dir/bin/prism_common.dll"
        copy.exclude "$dir/bin/prism_d3d.dll"
        copy.exclude "$dir/bin/prism_es2.dll"
        copy.exclude "$dir/bin/prism_sw.dll"
    }

    private static void pruneJRE(CopySpec copy, String dir) {
        copy.exclude "$dir/THIRDPARTYLICENSEREADME-JAVAFX.txt"

        copy.exclude "$dir/plugin/**"

        copy.exclude "$dir/lib/ext/access-bridge.jar"
        copy.exclude "$dir/lib/ext/access-bridge-32.jar"
        copy.exclude "$dir/lib/ext/access-bridge-64.jar"
        copy.exclude "$dir/lib/ext/cldrdata.jar"
        copy.exclude "$dir/lib/ext/jfxrt.jar"
        copy.exclude "$dir/lib/ext/localedata.jar"
        copy.exclude "$dir/lib/ext/nashorn.jar"
        copy.exclude "$dir/lib/ext/sunmscapi.jar"

        copy.exclude "$dir/lib/desktop/**"
        copy.exclude "$dir/lib/jfr/**"
        copy.exclude "$dir/lib/oblique-fonts/**"
        copy.exclude "$dir/lib/ant-javafx.jar"
        copy.exclude "$dir/lib/javafx.properties"
        copy.exclude "$dir/lib/javaws.jar"
        copy.exclude "$dir/lib/jfr.jar"
        copy.exclude "$dir/lib/jfxswt.jar"
    }

    private static String escapeWindows(String str) {
        return str.replaceAll(" ", "\\ ")
    }
}

class ScapesEngineApplicationExtension {
    def String name
    def String fullName
    def String version
    def String company
    def String url
    def String copyright
    def String uuid
    def String mainClass
}

class StartupScriptTask extends DefaultTask {
    @Input
    def output, execName, libPath, mainClass

    @OutputFile
    File getOutput() {
        project.file(output)
    }

    @TaskAction
    void run() {
        BufferedWriter writer = getOutput().newWriter()
        writer.write "#!/bin/bash\n"
        writer.write "export CLASSPATH=\"$libPath/*\"\n"
        writer.write "exec -a $execName java -Djava.library.path=$libPath $mainClass \$@\n"
        writer.close()
    }
}

class AppBundlerTask extends DefaultTask {
    @Input
    def output, fullName, version, company, copyright, mainClass, jre, appbundler, icon
    @InputFiles
    def FileCollection classpath

    @InputDirectory
    File getJRE() {
        project.file(jre)
    }

    @InputFile
    File getAppbundler() {
        project.file(appbundler)
    }

    @InputFile
    File getIcon() {
        project.file(icon)
    }

    @OutputDirectory
    File getOutput() {
        project.file(output)
    }

    @TaskAction
    void run() {
        def jre = getJRE()
        def appbundler = getAppbundler()
        def icon = getIcon()
        def output = getOutput()
        ant.taskdef(name: "bundleapp",
                classpath: appbundler.absolutePath,
                classname: "com.oracle.appbundler.AppBundlerTask")
        ant.bundleapp(outputdirectory: output.parentFile.absolutePath,
                name: output.name - ".app",
                displayname: fullName,
                identifier: mainClass,
                shortversion: version,
                icon: icon.absolutePath,
                mainclassname: mainClass,
                copyright: copyright,
                applicationCategory: "public.app-category.games",
                executableName: fullName) {
            classpath.addToAntBuilder(ant, "classpath",
                    FileCollection.AntType.FileSet)
            arch(name: "x86_64")
            runtime(dir: jre.absolutePath + "/Contents/Home")
            option(value: "-XstartOnFirstThread")
            option(value: "-Xms64M")
            option(value: "-Xmx2048M")
            option(value: "-XX:+UseG1GC")
            option(value: "-XX:MaxGCPauseMillis=1")
            option(value: "-Xdock:icon=Contents/resources/Icon.icns")
            argument(value: "\$HOME/Library/Application Support/$fullName")
        }
    }
}

class Launch4jTask extends DefaultTask {
    @Input
    def output, exeMemoryMin, exeMemoryMax, exeType, fullName, version, company, copyright, mainClass
    @Input
    boolean runInAppData
    @InputFile
    def File launch4j, icon, manifest

    @OutputFile
    File getOutput() {
        project.file(output)
    }

    @TaskAction
    void run() {
        ant.taskdef(name: "launch4j",
                classpath: launch4j.absolutePath,
                classname: "net.sf.launch4j.ant.Launch4jTask")
        def winVersion = version.replaceAll("_", ".")
        Map<String, String> configMap = [headerType: exeType,
                outfile: getOutput().absolutePath,
                dontWrapJar: "true",
                icon: icon.absolutePath,
                manifest: manifest.absolutePath]
        Map<String, String> versionMap = [fileversion: winVersion,
                txtfileversion: version,
                filedescription: fullName,
                copyright: copyright,
                productversion: winVersion,
                productname: fullName,
                txtproductversion: version,
                companyname: company,
                internalname: fullName,
                originalfilename: getOutput().name]
        Map<String, String> classPathMap = [mainClass: mainClass,
                cp: "%EXEDIR%\\lib\\*"];
        Map<String, String> jreMap = [initialheapsize: exeMemoryMin,
                maxheapsize: exeMemoryMax,
                path: "%EXEDIR%\\jre"]
        if (runInAppData) {
            ant.launch4j {
                config(configMap) {
                    classPath(classPathMap)
                    jre(jreMap) {
                        opt("-Duser.dir=\"%APPDATA%\\${fullName}\"")
                        opt("-Djava.library.path=\"%EXEDIR%\"")
                    }
                    versioninfo(versionMap)
                }
            }
        } else {
            ant.launch4j {
                config(configMap) {
                    classPath(classPathMap)
                    jre(jreMap)
                    versioninfo(versionMap)
                }
            }
        }
    }
}
