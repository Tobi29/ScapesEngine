/*
 * Copyright 2017, Gray Watson
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package com.j256.simplemagik.entries

import com.j256.simplemagik.endian.EndianConverter
import com.j256.simplemagik.entries.MagicMatcher.MutableOffset
import com.j256.simplemagik.types.IndirectType
import org.tobi29.arrays.ByteArraySliceRO
import org.tobi29.logging.KLogging
import org.tobi29.utils.MutableString

/**
 * Representation of a line of information from the magic (5) format. A number of methods are package protected because
 * this is generated by the [MagicEntryParser].
 *
 * @author graywatson
 */
class MagicEntry
/**
 * Package protected constructor.
 */
internal constructor(
    private val name: String?,
    /**
     * Return the "level" of the rule. Level-0 rules start the matching process. Level-1 and above rules are processed
     * only when the level-0 matches.
     */
    internal val level: Int,
    private val addOffset: Boolean,
    private val offset: Int,
    private val offsetInfo: OffsetInfo?,
    private val matcher: MagicMatcher,
    private val andValue: Long?,
    private val unsignedType: Boolean, // the testValue object is defined by the particular matcher
    private val testValue: Any?,
    private val formatSpacePrefix: Boolean,
    private val clearFormat: Boolean,
    private val formatter: MagicFormatter?
) {
    init {
        if (!addOffset && offset < 0 && offsetInfo == null)
            throw IllegalArgumentException("Negative offset: $offset")
    }

    /** if this entry matches then check the children entry(s) which may provide more content type details  */
    private val children = ArrayList<MagicEntry>()
    internal var mimeType: String? = null
    private val indirect: Boolean get() = matcher is IndirectType
    internal var isOptional: Boolean = false

    internal val startsWithByte: ByteArray?
        get() = if (offset != 0) {
            null
        } else {
            matcher.getStartingBytes(testValue)
        }

    /**
     * Returns the content type associated with the bytes or null if it does not match.
     */
    internal fun matchBytes(bytes: ByteArraySliceRO) =
        matchBytes(bytes, 0, 0, null)

    internal fun addChild(child: MagicEntry) {
        children.add(child)
    }

    override fun toString(): String {
        val sb = StringBuilder()
        sb.append("level ").append(level)
        val name = name
        val mimeType = mimeType
        val testValue = testValue
        val formatter = formatter
        if (name != null) {
            sb.append(",name '").append(name).append('\'')
        }
        if (mimeType != null) {
            sb.append(",mime '").append(mimeType).append('\'')
        }
        if (testValue != null) {
            sb.append(",test '").append(testValue).append('\'')
        }
        if (formatter != null) {
            sb.append(",format '").append(formatter).append('\'')
        }
        return sb.toString()
    }

    /**
     * Main processing method which can go recursive.
     */
    private fun matchBytes(
        bytes: ByteArraySliceRO,
        prevOffset: Int,
        level: Int,
        contentData: ContentData?
    ): ContentData? {
        var contentData = contentData
        var offset = (offsetInfo?.getOffset(bytes, prevOffset) ?: this.offset)
            .let { if (addOffset) it + prevOffset else it }
        val required = testValue == null && formatter != null
        var `val`: Any? = matcher.extractValueFromBytes(offset, bytes, required)
                ?: return null
        if (testValue != null) {
            val mutableOffset = MutableOffset(offset)
            `val` = matcher.isMatch(
                testValue,
                andValue,
                unsignedType,
                `val`,
                mutableOffset,
                bytes
            )
            if (`val` == null) return null
            offset = mutableOffset.offset
        }

        if (contentData == null) {
            contentData = ContentData(name, mimeType, level)
            // default is a child didn't match, set a partial so the matcher will keep looking
            contentData.partial = true
        }
        if (formatter != null) {
            if (clearFormat) {
                contentData.sb.clear()
            }
            // if we are appending and need a space then prepend one
            if (formatSpacePrefix && contentData.sb.length > 0) {
                contentData.sb.append(' ')
            }
            matcher.renderValue(contentData.sb, `val`, formatter)
        }
        if (indirect) contentData.indirect = true
        if (children.isEmpty()) contentData.offset = offset
        logger.trace { "matched data: $this: $contentData" }

        if (children.isEmpty()) {
            // no children so we have a full match and can set partial to false
            contentData.partial = false
        } else {
            // run through the children to add more content-type details
            var allOptional = true
            for (entry in children) {
                if (!entry.isOptional) {
                    allOptional = false
                }
                // goes recursive here
                entry.matchBytes(bytes, offset, level + 1, contentData)
                // we continue to match to see if we can add additional children info to the name
            }
            if (allOptional) {
                contentData.partial = false
            }
        }

        /*
		 * Now that we have processed this entry (either with or without children), see if we still need to annotate the
		 * content information.
		 *
		 * NOTE: the children will have the first opportunity to set this which makes sense since they are the most
		 * specific.
		 */
        if (name !== UNKNOWN_NAME && contentData.name === UNKNOWN_NAME) {
            contentData.name = name
        }
        /*
		 * Set the mime-type if it is not set already or if we've gotten more specific in the processing of a pattern
		 * and determine that it's actually a different type so we can override the previous mime-type. Example of this
		 * is Adobe Illustrator which looks like a PDF but has extra stuff in it.
		 */
        if (mimeType != null && (contentData.mimeType == null || level > contentData.mimeTypeLevel)) {
            contentData.mimeType = mimeType
            contentData.mimeTypeLevel = level
        }
        return contentData
    }

    /**
     * Internal processing data about the content.
     */
    internal data class ContentData(
        var name: String?,
        var mimeType: String?,
        var mimeTypeLevel: Int
    ) {
        var partial: Boolean = false
        var indirect: Boolean = false
        var offset: Int = 0
        val sb = MutableString()

        override fun toString(): String =
            "ContentData(name=$name, mimeType=$mimeType, mimeTypeLevel=$mimeTypeLevel, partial=$partial, indirect=$indirect, offset=$offset, sb=$sb)"
    }

    /**
     * Information about the extended offset.
     */
    internal class OffsetInfo(
        val offset: Int,
        val converter: EndianConverter,
        val addOffset: Boolean,
        val isId3: Boolean,
        val size: Int,
        val add: Int
    ) {

        fun getOffset(
            bytes: ByteArraySliceRO,
            prevOffset: Int
        ): Int {
            val off = if (isId3) {
                converter.convertId3(offset, bytes, size)!!
            } else {
                converter.convertNumber(offset, bytes, size)!!
            }
            return (off + add).toInt()
                .let { if (addOffset) it + prevOffset else it }
        }
    }

    companion object : KLogging() {
        internal const val UNKNOWN_NAME = "unknown"
    }
}
